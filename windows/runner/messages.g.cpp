// Autogenerated from Pigeon (v17.1.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
    return FlutterError(
        "channel-error",
        "Unable to establish connection on channel: '" + channel_name + "'.",
        EncodableValue(""));
}

// AudioData

AudioData::AudioData(
  const std::string& url,
  const Track& track)
 : url_(url),
    track_(track) {}

const std::string& AudioData::url() const {
  return url_;
}

void AudioData::set_url(std::string_view value_arg) {
  url_ = value_arg;
}


const Track& AudioData::track() const {
  return track_;
}

void AudioData::set_track(const Track& value_arg) {
  track_ = value_arg;
}


EncodableList AudioData::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(url_));
  list.push_back(EncodableValue(track_.ToEncodableList()));
  return list;
}

AudioData AudioData::FromEncodableList(const EncodableList& list) {
  AudioData decoded(
    std::get<std::string>(list[0]),
    Track::FromEncodableList(std::get<EncodableList>(list[1])));
  return decoded;
}

// PlaybackState

PlaybackState::PlaybackState(
  bool is_playing,
  bool is_buffering,
  bool is_seeking,
  bool is_completed,
  int64_t position,
  int64_t duration,
  const Speed& speed,
  int64_t volume,
  const Track& track)
 : is_playing_(is_playing),
    is_buffering_(is_buffering),
    is_seeking_(is_seeking),
    is_completed_(is_completed),
    position_(position),
    duration_(duration),
    speed_(speed),
    volume_(volume),
    track_(track) {}

PlaybackState::PlaybackState(
  bool is_playing,
  bool is_buffering,
  bool is_seeking,
  bool is_completed,
  int64_t position,
  int64_t duration,
  const Speed& speed,
  int64_t volume,
  const Track& track,
  const BackgroundSound* background_sound)
 : is_playing_(is_playing),
    is_buffering_(is_buffering),
    is_seeking_(is_seeking),
    is_completed_(is_completed),
    position_(position),
    duration_(duration),
    speed_(speed),
    volume_(volume),
    track_(track),
    background_sound_(background_sound ? std::optional<BackgroundSound>(*background_sound) : std::nullopt) {}

bool PlaybackState::is_playing() const {
  return is_playing_;
}

void PlaybackState::set_is_playing(bool value_arg) {
  is_playing_ = value_arg;
}


bool PlaybackState::is_buffering() const {
  return is_buffering_;
}

void PlaybackState::set_is_buffering(bool value_arg) {
  is_buffering_ = value_arg;
}


bool PlaybackState::is_seeking() const {
  return is_seeking_;
}

void PlaybackState::set_is_seeking(bool value_arg) {
  is_seeking_ = value_arg;
}


bool PlaybackState::is_completed() const {
  return is_completed_;
}

void PlaybackState::set_is_completed(bool value_arg) {
  is_completed_ = value_arg;
}


int64_t PlaybackState::position() const {
  return position_;
}

void PlaybackState::set_position(int64_t value_arg) {
  position_ = value_arg;
}


int64_t PlaybackState::duration() const {
  return duration_;
}

void PlaybackState::set_duration(int64_t value_arg) {
  duration_ = value_arg;
}


const Speed& PlaybackState::speed() const {
  return speed_;
}

void PlaybackState::set_speed(const Speed& value_arg) {
  speed_ = value_arg;
}


int64_t PlaybackState::volume() const {
  return volume_;
}

void PlaybackState::set_volume(int64_t value_arg) {
  volume_ = value_arg;
}


const Track& PlaybackState::track() const {
  return track_;
}

void PlaybackState::set_track(const Track& value_arg) {
  track_ = value_arg;
}


const BackgroundSound* PlaybackState::background_sound() const {
  return background_sound_ ? &(*background_sound_) : nullptr;
}

void PlaybackState::set_background_sound(const BackgroundSound* value_arg) {
  background_sound_ = value_arg ? std::optional<BackgroundSound>(*value_arg) : std::nullopt;
}

void PlaybackState::set_background_sound(const BackgroundSound& value_arg) {
  background_sound_ = value_arg;
}


EncodableList PlaybackState::ToEncodableList() const {
  EncodableList list;
  list.reserve(10);
  list.push_back(EncodableValue(is_playing_));
  list.push_back(EncodableValue(is_buffering_));
  list.push_back(EncodableValue(is_seeking_));
  list.push_back(EncodableValue(is_completed_));
  list.push_back(EncodableValue(position_));
  list.push_back(EncodableValue(duration_));
  list.push_back(EncodableValue(speed_.ToEncodableList()));
  list.push_back(EncodableValue(volume_));
  list.push_back(EncodableValue(track_.ToEncodableList()));
  list.push_back(background_sound_ ? EncodableValue(background_sound_->ToEncodableList()) : EncodableValue());
  return list;
}

PlaybackState PlaybackState::FromEncodableList(const EncodableList& list) {
  PlaybackState decoded(
    std::get<bool>(list[0]),
    std::get<bool>(list[1]),
    std::get<bool>(list[2]),
    std::get<bool>(list[3]),
    list[4].LongValue(),
    list[5].LongValue(),
    Speed::FromEncodableList(std::get<EncodableList>(list[6])),
    list[7].LongValue(),
    Track::FromEncodableList(std::get<EncodableList>(list[8])));
  auto& encodable_background_sound = list[9];
  if (!encodable_background_sound.IsNull()) {
    decoded.set_background_sound(BackgroundSound::FromEncodableList(std::get<EncodableList>(encodable_background_sound)));
  }
  return decoded;
}

// BackgroundSound

BackgroundSound::BackgroundSound(const std::string& title)
 : title_(title) {}

BackgroundSound::BackgroundSound(
  const std::string* uri,
  const std::string& title)
 : uri_(uri ? std::optional<std::string>(*uri) : std::nullopt),
    title_(title) {}

const std::string* BackgroundSound::uri() const {
  return uri_ ? &(*uri_) : nullptr;
}

void BackgroundSound::set_uri(const std::string_view* value_arg) {
  uri_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void BackgroundSound::set_uri(std::string_view value_arg) {
  uri_ = value_arg;
}


const std::string& BackgroundSound::title() const {
  return title_;
}

void BackgroundSound::set_title(std::string_view value_arg) {
  title_ = value_arg;
}


EncodableList BackgroundSound::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(uri_ ? EncodableValue(*uri_) : EncodableValue());
  list.push_back(EncodableValue(title_));
  return list;
}

BackgroundSound BackgroundSound::FromEncodableList(const EncodableList& list) {
  BackgroundSound decoded(
    std::get<std::string>(list[1]));
  auto& encodable_uri = list[0];
  if (!encodable_uri.IsNull()) {
    decoded.set_uri(std::get<std::string>(encodable_uri));
  }
  return decoded;
}

// Speed

Speed::Speed(double speed)
 : speed_(speed) {}

double Speed::speed() const {
  return speed_;
}

void Speed::set_speed(double value_arg) {
  speed_ = value_arg;
}


EncodableList Speed::ToEncodableList() const {
  EncodableList list;
  list.reserve(1);
  list.push_back(EncodableValue(speed_));
  return list;
}

Speed Speed::FromEncodableList(const EncodableList& list) {
  Speed decoded(
    std::get<double>(list[0]));
  return decoded;
}

// Track

Track::Track(
  const std::string& title,
  const std::string& description,
  const std::string& image_url)
 : title_(title),
    description_(description),
    image_url_(image_url) {}

Track::Track(
  const std::string& title,
  const std::string& description,
  const std::string& image_url,
  const std::string* artist,
  const std::string* artist_url)
 : title_(title),
    description_(description),
    image_url_(image_url),
    artist_(artist ? std::optional<std::string>(*artist) : std::nullopt),
    artist_url_(artist_url ? std::optional<std::string>(*artist_url) : std::nullopt) {}

const std::string& Track::title() const {
  return title_;
}

void Track::set_title(std::string_view value_arg) {
  title_ = value_arg;
}


const std::string& Track::description() const {
  return description_;
}

void Track::set_description(std::string_view value_arg) {
  description_ = value_arg;
}


const std::string& Track::image_url() const {
  return image_url_;
}

void Track::set_image_url(std::string_view value_arg) {
  image_url_ = value_arg;
}


const std::string* Track::artist() const {
  return artist_ ? &(*artist_) : nullptr;
}

void Track::set_artist(const std::string_view* value_arg) {
  artist_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void Track::set_artist(std::string_view value_arg) {
  artist_ = value_arg;
}


const std::string* Track::artist_url() const {
  return artist_url_ ? &(*artist_url_) : nullptr;
}

void Track::set_artist_url(const std::string_view* value_arg) {
  artist_url_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void Track::set_artist_url(std::string_view value_arg) {
  artist_url_ = value_arg;
}


EncodableList Track::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(EncodableValue(title_));
  list.push_back(EncodableValue(description_));
  list.push_back(EncodableValue(image_url_));
  list.push_back(artist_ ? EncodableValue(*artist_) : EncodableValue());
  list.push_back(artist_url_ ? EncodableValue(*artist_url_) : EncodableValue());
  return list;
}

Track Track::FromEncodableList(const EncodableList& list) {
  Track decoded(
    std::get<std::string>(list[0]),
    std::get<std::string>(list[1]),
    std::get<std::string>(list[2]));
  auto& encodable_artist = list[3];
  if (!encodable_artist.IsNull()) {
    decoded.set_artist(std::get<std::string>(encodable_artist));
  }
  auto& encodable_artist_url = list[4];
  if (!encodable_artist_url.IsNull()) {
    decoded.set_artist_url(std::get<std::string>(encodable_artist_url));
  }
  return decoded;
}

/// The codec used by MeditoAndroidAudioServiceManager.
const flutter::StandardMessageCodec& MeditoAndroidAudioServiceManager::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&flutter::StandardCodecSerializer::GetInstance());
}

// Sets up an instance of `MeditoAndroidAudioServiceManager` to handle messages through the `binary_messenger`.
void MeditoAndroidAudioServiceManager::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MeditoAndroidAudioServiceManager* api) {
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAndroidAudioServiceManager.startService", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->StartService();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MeditoAndroidAudioServiceManager::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MeditoAndroidAudioServiceManager::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


MeditoAudioServiceApiCodecSerializer::MeditoAudioServiceApiCodecSerializer() {}

EncodableValue MeditoAudioServiceApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(AudioData::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(Track::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MeditoAudioServiceApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(AudioData)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<AudioData>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(Track)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<Track>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by MeditoAudioServiceApi.
const flutter::StandardMessageCodec& MeditoAudioServiceApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&MeditoAudioServiceApiCodecSerializer::GetInstance());
}

// Sets up an instance of `MeditoAudioServiceApi` to handle messages through the `binary_messenger`.
void MeditoAudioServiceApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  MeditoAudioServiceApi* api) {
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playAudio", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_audio_data_arg = args.at(0);
          if (encodable_audio_data_arg.IsNull()) {
            reply(WrapError("audio_data_arg unexpectedly null."));
            return;
          }
          const auto& audio_data_arg = std::any_cast<const AudioData&>(std::get<CustomEncodableValue>(encodable_audio_data_arg));
          ErrorOr<bool> output = api->PlayAudio(audio_data_arg);
          if (output.has_error()) {
            reply(WrapError(output.error()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playPauseAudio", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->PlayPauseAudio();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.stopAudio", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->StopAudio();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setSpeed", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_speed_arg = args.at(0);
          if (encodable_speed_arg.IsNull()) {
            reply(WrapError("speed_arg unexpectedly null."));
            return;
          }
          const auto& speed_arg = std::get<double>(encodable_speed_arg);
          std::optional<FlutterError> output = api->SetSpeed(speed_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.seekToPosition", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_position_arg = args.at(0);
          if (encodable_position_arg.IsNull()) {
            reply(WrapError("position_arg unexpectedly null."));
            return;
          }
          const int64_t position_arg = encodable_position_arg.LongValue();
          std::optional<FlutterError> output = api->SeekToPosition(position_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.skip10SecondsForward", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->Skip10SecondsForward();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.skip10SecondsBackward", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->Skip10SecondsBackward();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setBackgroundSound", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_uri_arg = args.at(0);
          const auto* uri_arg = std::get_if<std::string>(&encodable_uri_arg);
          std::optional<FlutterError> output = api->SetBackgroundSound(uri_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setBackgroundSoundVolume", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_volume_arg = args.at(0);
          if (encodable_volume_arg.IsNull()) {
            reply(WrapError("volume_arg unexpectedly null."));
            return;
          }
          const auto& volume_arg = std::get<double>(encodable_volume_arg);
          std::optional<FlutterError> output = api->SetBackgroundSoundVolume(volume_arg);
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.stopBackgroundSound", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->StopBackgroundSound();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playBackgroundSound", &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          std::optional<FlutterError> output = api->PlayBackgroundSound();
          if (output.has_value()) {
            reply(WrapError(output.value()));
            return;
          }
          EncodableList wrapped;
          wrapped.push_back(EncodableValue());
          reply(EncodableValue(std::move(wrapped)));
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue MeditoAudioServiceApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue MeditoAudioServiceApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}


MeditoAudioServiceCallbackApiCodecSerializer::MeditoAudioServiceCallbackApiCodecSerializer() {}

EncodableValue MeditoAudioServiceCallbackApiCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 128:
      return CustomEncodableValue(BackgroundSound::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 129:
      return CustomEncodableValue(PlaybackState::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 130:
      return CustomEncodableValue(Speed::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    case 131:
      return CustomEncodableValue(Track::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
  }
}

void MeditoAudioServiceCallbackApiCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(BackgroundSound)) {
      stream->WriteByte(128);
      WriteValue(EncodableValue(std::any_cast<BackgroundSound>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(PlaybackState)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(std::any_cast<PlaybackState>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(Speed)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<Speed>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(Track)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<Track>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

// Generated class from Pigeon that represents Flutter messages that can be called from C++.
MeditoAudioServiceCallbackApi::MeditoAudioServiceCallbackApi(flutter::BinaryMessenger* binary_messenger)
 : binary_messenger_(binary_messenger) {}

const flutter::StandardMessageCodec& MeditoAudioServiceCallbackApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&MeditoAudioServiceCallbackApiCodecSerializer::GetInstance());
}

void MeditoAudioServiceCallbackApi::UpdatePlaybackState(
  const PlaybackState& state_arg,
  std::function<void(void)>&& on_success,
  std::function<void(const FlutterError&)>&& on_error) {
  const std::string channel_name = "dev.flutter.pigeon.Medito.MeditoAudioServiceCallbackApi.updatePlaybackState";
  BasicMessageChannel<> channel(binary_messenger_, channel_name, &GetCodec());
  EncodableValue encoded_api_arguments = EncodableValue(EncodableList{
    CustomEncodableValue(state_arg),
  });
  channel.Send(encoded_api_arguments, [channel_name, on_success = std::move(on_success), on_error = std::move(on_error)](const uint8_t* reply, size_t reply_size) {
    std::unique_ptr<EncodableValue> response = GetCodec().DecodeMessage(reply, reply_size);
    const auto& encodable_return_value = *response;
    const auto* list_return_value = std::get_if<EncodableList>(&encodable_return_value);
    if (list_return_value) {
      if (list_return_value->size() > 1) {
        on_error(FlutterError(std::get<std::string>(list_return_value->at(0)), std::get<std::string>(list_return_value->at(1)), list_return_value->at(2)));
      } else {
        on_success();
      }
    } else {
      on_error(CreateConnectionError(channel_name));
    } 
  });
}

